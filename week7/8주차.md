# Week 8: 로그인/회원가입 + 라우팅 정리

## 1. JWT vs Session 차이

### 1) 구조 차이

- **Session (세션)**

  - 서버가 클라이언트의 로그인 정보를 **서버 메모리나 데이터베이스에 직접 저장**합니다.
  - 클라이언트에게는 이 정보를 식별할 수 있는 `Session ID`만을 쿠키(Cookie) 등을 통해 전달합니다.
  - 클라이언트가 요청을 보낼 때 `Session ID`를 함께 보내면, 서버가 내부 저장소에서 일치하는 정보를 찾아 유저를 식별합니다.

- **JWT (Json Web Token)**
  - 유저의 정보를 **토큰(Token) 자체에 담아서** 클라이언트에게 발급합니다.
  - 토큰은 Header, Payload, Verify Signature 세 부분으로 구성되며, 서버는 별도의 저장소 확인 없이 토큰의 서명(Signature)만 검증하여 유효성을 확인합니다.
  - 클라이언트는 이 토큰을 `localStorage`나 `sessionStorage`에 저장해두고 요청 시마다 헤더에 실어 보냅니다.

### 2) 서버 상태관리 차이 (Stateful vs Stateless)

- **Session: Stateful (상태 유지)**

  - 서버가 클라이언트의 상태(로그인 여부 등)를 계속 기억하고 있어야 합니다.
  - 사용자가 늘어나면 서버의 메모리 부하가 커질 수 있으며, 서버를 여러 대(Scale-out)로 확장할 때 세션 불일치 문제를 해결하기 위한 추가 설정(Redis 등)이 필요합니다.

- **JWT: Stateless (무상태)**
  - 서버는 클라이언트의 상태를 저장하지 않습니다.
  - 오직 들어오는 토큰이 위조되지 않았는지만 검증하면 되므로, 서버 확장이 용이하고 부하가 적습니다.

### 3) 보안 차이

- **Session**: `Session ID`를 탈취당해도 서버에서 해당 세션을 강제로 삭제(만료)시키면 되므로 관리가 비교적 쉽습니다. 하지만 쿠키를 사용할 경우 CSRF 공격에 취약할 수 있습니다.
- **JWT**: 한 번 발급된 토큰은 유효기간이 만료될 때까지 서버에서 제어하기 어렵습니다(탈취 시 위험). `localStorage`에 저장할 경우 XSS(스크립트 삽입) 공격에 취약할 수 있어 보안에 신경 써야 합니다.

---

## 2. 라우터 구성 (React Router)

### 1) 필수 라우트 구조

과제 요구사항에 따라 다음과 같이 라우터를 구성하였습니다.

- `/`: 메인 페이지 (로그인 여부에 따라 헤더 버튼 변경)
- `/login`: 로그인 페이지 (이메일/비밀번호 입력, 토큰 발급)
- `/register`: 회원가입 페이지 (API 연동)
- `/dashboard`: 로그인 성공 시에만 접근 가능한 보호된 페이지

### 2) 구현 핵심 내용

- **페이지 이동**: `useNavigate` 훅을 사용하여 로그인/회원가입 성공 시 페이지를 강제로 이동시켰습니다.
- **인증 상태에 따른 분기 처리**:
  - 로그인 전: Header에 "로그인 / 회원가입" 버튼 노출
  - 로그인 후: Header에 "로그아웃" 버튼 노출 및 토큰 삭제 기능 구현
- **접근 제한 (Protected Route)**: `localStorage`에 토큰이 없으면 대시보드 접근 시 로그인 페이지로 리다이렉트(`Maps`) 되도록 처리했습니다.

---

## 3. 구현하면서 느낀 점

- **API 연동의 흐름 이해**: 단순히 화면을 만드는 것을 넘어, `POST` 요청을 보내고 응답받은 JWT를 브라우저 저장소(`localStorage`)에 저장하는 전체적인 인증 프로세스를 이해하게 되었습니다.
- **비동기 처리의 중요성**: 회원가입이나 로그인 시 서버 응답을 기다렸다가(await) 성공 여부에 따라 `Maps`로 페이지를 이동시키는 로직을 구현하며 비동기 처리의 필요성을 체감했습니다.
- **상태 관리의 필요성**: 새로고침 시 로그인이 풀리지 않게 하려면 저장된 토큰을 읽어와 초기 상태를 설정해야 한다는 점을 배웠습니다.
