# 2주차 개념 정리: JSX, State, Props ⚛️

## 1. JSX (JavaScript XML)

**JSX**는 JavaScript를 확장한 문법으로, React에서 UI가 어떻게 생겨야 하는지를 설명하기 위해 사용됩니다. HTML과 매우 비슷하게 생겼지만, 실제로는 JavaScript입니다.

### 🤔 JSX는 왜 사용할까?

- **가독성 향상**: 마크업(`HTML`)과 로직(`JavaScript`)을 하나의 파일에서 함께 작성하여 컴포넌트의 구조를 한눈에 파악하기 쉽습니다.
- **개발 편의성**: JavaScript의 모든 기능을 활용하면서 익숙한 HTML 태그 방식으로 UI를 작성할 수 있어 편리합니다.

### 📋 주요 문법 규칙

1.  **하나의 부모 요소로 감싸기**: 모든 요소는 하나의 최상위 태그(`<div>`, `<> Fragment` 등)로 감싸야 합니다.

    ```jsx
    // 잘못된 예시 ❌
    // return (
    //   <h1>안녕하세요</h1>
    //   <p>리액트입니다</p>
    // );

    // 올바른 예시 ✅
    return (
      <div>
        <h1>안녕하세요</h1>
        <p>리액트입니다</p>
      </div>
    );
    ```

2.  **JavaScript 표현식 사용**: 중괄호 `{}`를 사용하면 JSX 내부에 변수나 JavaScript 코드를 삽입할 수 있습니다.

    ```jsx
    const name = 'React';
    const element = <h1>Hello, {name}</h1>; // "Hello, React"가 됨
    ```

3.  **HTML과 다른 속성 이름**: `class`는 `className`으로, `for`는 `htmlFor`로 작성해야 합니다. JavaScript의 예약어와 충돌을 피하기 위함입니다.

    ```jsx
    const element = <div className="greeting">Hello!</div>;
    ```

4.  **인라인 스타일링**: 스타일은 객체 형태로 작성하며, CSS 속성은 카멜 케이스(camelCase)로 작성합니다.

    ```jsx
    const style = {
      backgroundColor: 'black',
      color: 'white',
      fontSize: '16px', // 숫자로만 적어도 px로 인식
    };

    const element = <div style={style}>Styled Div</div>;
    ```

---

## 2. Props (Properties)

**Props**는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때 사용하는 **읽기 전용(read-only)** 데이터입니다. 컴포넌트를 재사용 가능하게 만드는 핵심 요소입니다.

- **비유**: 함수에 전달되는 **인자(argument)**와 같습니다.

### 👨‍👩‍👧 Props 사용법

1.  **부모 컴포넌트에서 데이터 전달**: 자식 컴포넌트에 HTML 속성처럼 `prop이름="값"` 형식으로 데이터를 전달합니다.

    ```jsx
    // 부모 컴포넌트: App.js
    function App() {
      return <Greeting name="Sarah" age={25} />;
    }
    ```

2.  **자식 컴포넌트에서 데이터 받기**: 자식 컴포넌트는 함수의 매개변수로 `props` 객체를 받아 데이터를 사용합니다.

    ```jsx
    // 자식 컴포넌트: Greeting.js
    function Greeting(props) {
      return (
        <h1>
          안녕하세요, {props.name}님! {props.age}살이시군요.
        </h1>
      );
    }
    ```

### ⚠️ 중요한 특징

- **읽기 전용**: 자식 컴포넌트는 전달받은 `props`를 **절대 직접 수정해서는 안 됩니다**. 데이터 흐름은 항상 위에서 아래로(단방향) 흐릅니다.

---

## 3. State

**State**는 컴포넌트가 **내부에서 직접 관리하는 데이터**입니다. 사용자의 인터랙션 등으로 인해 **값이 변할 수 있으며**, state가 변경되면 React가 자동으로 화면을 다시 렌더링(re-rendering)합니다.

- **비유**: 컴포넌트가 사용하는 "개인 사물함"이나 "메모장"과 같습니다.

### useState 사용법

React v16.8부터는 함수형 컴포넌트에서 `useState` Hook을 사용하여 state를 관리합니다.

1.  **`useState` 불러오기**: `react` 라이브러리에서 `useState`를 import 합니다.

    ```jsx
    import React, { useState } from 'react';
    ```

2.  **State 변수 선언**: `useState(초기값)`는 배열을 반환합니다. 첫 번째 요소는 **현재 state 값**, 두 번째 요소는 **state를 업데이트하는 함수**입니다.

    ```jsx
    function Counter() {
      // count: 현재 상태 값, setCount: 상태를 업데이트하는 함수
      const [count, setCount] = useState(0); // 0은 초기값
    ```

3.  **State 사용 및 업데이트**:

    - state 값은 `count` 변수를 직접 읽어서 사용합니다.
    - state를 변경할 때는 반드시 `setCount` 함수를 사용해야 합니다. **`count = count + 1` 처럼 직접 수정하면 안 됩니다!**

    ```jsx
    // 전체 Counter 컴포넌트 예시
    function Counter() {
      const [count, setCount] = useState(0);

      const handleIncrease = () => {
        setCount(count + 1); // setCount 함수로 상태 업데이트
      };

      return (
        <div>
          <p>현재 카운트: {count}</p>
          <button onClick={handleIncrease}>+1 증가</button>
        </div>
      );
    }
    ```

## 🔄 State vs Props 비교

| 구분               | **Props**               | **State**                       |
| ------------------ | ----------------------- | ------------------------------- |
| **목적**           | 부모 → 자식 데이터 전달 | 컴포넌트 내부 데이터 관리       |
| **데이터 흐름**    | 단방향 (위에서 아래로)  | 컴포넌트 내에서 발생하고 관리됨 |
| **수정 가능 여부** | **불가능** (읽기 전용)  | **가능** (세터 함수를 통해)     |
| **소유권**         | 부모 컴포넌트           | 컴포넌트 자신                   |

## 🤔 2주차 학습 회고

### 💡 이런 점이 좋았어요!

- **편한 JSX**: HTML처럼 생겨서 코드를 한눈에 알아보기 쉬웠습니다. JavaScript 파일 안에서 화면 모양과 동작을 같이 만드니, 코드가 어떻게 움직일지 상상하기 더 좋았습니다.
- **똑똑한 State**: `useState`로 값을 바꾸면 화면이 알아서 바뀌는 게 편리했습니다. 예전처럼 컴퓨터에 일일이 명령하지 않고, 그냥 데이터가 바뀌었다고 알려주기만 하면 되니까 좋았습니다.
- **편리한 심부름꾼 Props**: 부모 컴포넌트가 자식 컴포넌트에게 '이러한 데이터를 받으라'고 `props`로 시키는 방식이 좋았습니다. 데이터가 어디서 오는지 길이 딱 정해져 있으니까, 코드가 꼬이지 않고 수정하기에도 쉬웠어요.

### 😢 이 부분은 조금 어려웠어요 :|

- **끝없는 심부름**: `App`에서 `TodoList`를 거쳐 `TodoItem`까지, 계속 `props`로 심부름을 시키는 게 조금 번거롭게 느껴졌습니다. 나중에 컴포넌트가 더 많아지면 훨씬 힘들 것 같아요.
- **복사해서 쓰기 (불변성)**: 데이터를 바꿀 때, 원래 있던 데이터를 고치지 않고 항상 복사본을 만들어서 써야 한다는 규칙이 헷갈렸습니다.

### 📖 다음에는 이것도 공부해보고 싶어요 :)

- **순간이동 장치 (전역 상태 관리)**: Props 심부름을 계속 시키는 대신, 어디서든 데이터를 바로 꺼내 쓸 수 있는 기술이 있다면 배워보고 싶어요.
- **더욱 다양한 React 기능**: 더 다양한 React 기능을 배우고 싶습니다.
