### JSX?
- JSX는 JavaScript를 확장한 문법입니다. const element = <h1>Hello, world!</h1>; 이러한 방식으로 HTML을 사용할 수 있습니다
- React는 별도의 파일에 마크업과 로직을 넣어 기술을 인위적으로 분리하는 대신 둘을 포함하는 컴포넌트를 만들어 사용합니다. 이렇게 하면 관심사를 분리할 수 있습니다.
- JSX는 HTML 보다 JavaScript에 가깝기 때문에, React DOM은 HTML 어트리뷰트 이름 대신 camelCase 프로퍼티 명명 규칙을 사용합니다.(camelCase 특징 첫 단어는 소문자로 시작, 그 뒤 단어들은 첫 글자를 대문자로 씀)
- JSX는 주입공격을 방지합니다. React는 JSX에 변수를 넣을 때 자동으로 이스케이프(escape) 처리를 해줍니다.
```jsx
function App() {
  const userInput = '<img src=x onerror=alert("해킹!")>';
  return <div>{userInput}</div>;
}
```
- 이런 식으로 값이 들어와도 HTML 코드로 실행하지 않고 문자열 취급을 합니다
- React에서 dangerouslySetInnerHTML을 쓰면 예외적으로 문자열을 HTML로 직접 삽입할 수 있는데, 이 경우 보안에 취약해질 수 있습니다.
### State?
- State는 객체를 포함한 모든 종류의 자바스크립트 값을 가질 수 있습니다. 
- react에서는 state의 값을 변경하면 안되고 새로운 객체를 생성하여 값을 복사하여 사용해야 합니다. 그렇게 해야만 값이 변경되었다고 인지를 할 수 있습니다.
- state에 저장한 자바스크립트 객체는 어떤 것이라도 읽기 전용인 것처럼 다루어야 합니다. 
```jsx
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}
```
- 이런 식으로 코드를 짜면 react는 객체가 변경되었는지 알 수 없어 아무것도 하지 않습니다
```jsx
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```
- 이런식으로 짜야만 객체가 새로 만들어져 리렌더링이 발생합니다.
```jsx
setPerson({
  ...person, // 이전 필드를 복사
  firstName: e.target.value // 새로운 부분은 덮어쓰기
});
```
- 만약 한가지의 속성값만 바꾸고 싶다면 모든 속성값을 다 작성할 필요가 없거 ...객체 전개 구문을 사용하여 복사 할 수 있습니다.
## 중첩된 객체 갱신하기
```jsx
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
});
```
- 이런 중첩된 객체에서 만약 city만 바꾸고 싶다면 person.artwork.city = 'New Delhi'; 이런식으로 하면 큰일난다
```jsx
const nextArtwork = { ...person.artwork, city: 'New Delhi' };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);


setPerson({
  ...person, // 다른 필드 복사
  artwork: { // artwork 교체
    ...person.artwork, // 동일한 값 사용
    city: 'New Delhi' // 하지만 New Delhi!
  }
});
```
- 중첩된 객체는 이러한 방법중 한가지를 선택해서 사용하면 됩니다 
- 또는 Immer를 사용하여 편리하게 바꿀 수 있습니다
### Props?
- props는 React 컴포넌트에 전달되는 입력값을 말합니다.
- 즉, 부모 컴포넌트가 자식 컴포넌트에게 데이터를 넘겨줄 때 사용하는 객체입니다.

## 특징

- 읽기 전용 (immutable)
- 자식 컴포넌트는 받은 props를 직접 수정할 수 없고, 오직 읽기만 합니다.
- (값을 바꾸고 싶다면 부모에서 상태(state)를 변경해야 함)

- 객체 형태
- 실제로는 자바스크립트 객체로 전달됩니다. { key: value } 구조

- 동적 렌더링 가능
- props 값이 바뀌면 컴포넌트는 다시 렌더링 됩니다.
- java에서는 파라미터와 비슷한 느낌?
## 컴포넌트에 props 전달하기
```jsx
export default function Profile() {
  return (
    <Avatar
      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}
      size={100}
    />
  );
}

function Avatar({ person, size }) {
  // person과 size는 이곳에서 사용가능합니다.
}
```
- 이런식으로 person과 size를 받을 수 있습니다

## props state 차이
| 구분       | props                                      | state                                        |
| --------  | ---------------------------                | ----------------------------------------     |
| 정의       | 부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터   | 컴포넌트 내부에서 관리하는 데이터                |
| 수정가능여부 | **읽기 전용** (자식에서 변경 불가)          | **수정 가능** (`setState` 혹은 `useState`로 변경)   |
| 책임       | 데이터 소유자는 부모                          | 데이터 소유자는 해당 컴포넌트 자신                |
| 용도       | 컴포넌트에 외부에서 주입되는 값                 | 컴포넌트의 내부에서 바뀌는 값(상태)              |
| 예시       | 사용자 이름, 스타일, 자식 컴포넌트에 넘겨줄 값   | 버튼 클릭 횟수, 입력 폼 값, 모달 열림 여부        |


### todoList
- export default App; // "다른 파일에서 이 App 컴포넌트를 사용할 수 있게 내보내기"
- import App from './App'; // App.js에서 내보낸 App 컴포넌트를 가져오기
- useState : 초기값 설정
- setTodos([...todos, { id: Date.now(), text: inputValue, completed: false }]); 새로운 객체를 만들어서 복사를 한다음 값을 넣음
- React에서 useEffect는 함수형 컴포넌트에서 부수 효과(side effect)를 처리하는 훅(Hook)이다.
- - 부수 효과: 컴포넌트 렌더링과 직접 관련이 없는 작업(예: 데이터 fetching, DOM 조작, 타이머, 구독(subscribe), 로깅 등)
- - hook: 함수형 컴포넌트에서 상태 관리와 라이프사이클 기능을 사용하게 해주는 특수 함수(useState, useEffect, useRef)
- <div>: HTML의 블록 레벨 요소
- <form>: 사용자 입력을 제출할 수 있는 영역(input과 button을 포함)
- - 일반 HTML에서는 폼 제출 시 페이지가 새로고침되지만, React에서는 보통 handleSubmit에서 event.preventDefault()를 써서 페이지 새로고침 없이 처리함