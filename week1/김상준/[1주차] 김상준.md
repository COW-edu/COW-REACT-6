# 📚 1주차 학습

## 1. 브라우저는 어떻게 동작하는가?

### 1-1. 브라우저의 정의
브라우저는 사용자가 인터넷에 접속해서 웹 페이지(HTML, CSS, JavaScript 등)와 같은 웹 리소스를 열람할 수 있도록 해주는 소프트웨어 프로그램이다.

학술적으로는 **사용자 에이전트(User Agent)**의 한 종류로 정의된다.
- **사용자 에이전트(User Agent)**: 사용자를 대신해 웹 서버에 접속하여 정보를 요청(Request)하고, 받아온 정보를 처리(Processing)·렌더링(Rendering)하여 사람이 이해할 수 있는 형태로 제공하는 소프트웨어.

즉, 웹 브라우저는 **웹 표준 기술(HTTP, HTML, CSS, JavaScript 등)을 구현하여, 사용자가 WWW(World Wide Web)의 정보 자원을 검색·표현·상호작용할 수 있도록 하는 사용자 에이전트 소프트웨어**이다.

---

### 1-2. 브라우저의 역할
브라우저가 수행하는 핵심 역할은 크게 네 가지다.
1. **리소스 요청(Request)**: 서버로부터 웹 자원(HTML, CSS, JS, 이미지 등)을 가져온다.
2. **리소스 해석(Parsing)**: 가져온 자원을 규격에 맞게 해석한다.
3. **표현(Rendering)**: 해석한 결과를 화면에 그려 사용자에게 보여준다.
4. **상호작용(Interaction)**: 사용자의 입력과 자바스크립트 실행을 통해 페이지와 동적으로 상호작용한다.

---

### 1-3. 브라우저의 구성 요소
브라우저는 위 역할을 수행하기 위해 다음과 같은 구성 요소를 가진다.
- **사용자 인터페이스(UI)**: 주소창, 탭, 버튼 등 사용자가 브라우저와 상호작용하는 부분
- **네트워크 모듈**: HTTP/HTTPS 요청·응답 처리, 캐싱
- **렌더링 엔진(Rendering Engine)**: HTML, CSS 파싱 → DOM, CSSOM 생성 → Render Tree → Layout → Paint → 화면 출력
- **자바스크립트 엔진(JavaScript Engine)**: JS 코드 실행, DOM/CSSOM 조작, 비동기 요청 처리
- **데이터 저장소(Storage)**: 쿠키, LocalStorage, IndexedDB 등 클라이언트 측 데이터 저장
- **보안 모듈(Security)**: HTTPS, 동일 출처 정책(SOP), CSP 등을 통한 안전한 실행 환경 보장

---

### 1-4. 브라우저의 동작 과정

브라우저의 동작은 크게 **① 리소스 요청 → ② 리소스 수신 → ③ 리소스 해석 및 표현 → ④ 상호작용** 네 가지 역할로 구분할 수 있다.  
아래는 각 역할에 따른 세부 동작이다.

---

#### ① 리소스 요청 (Request)

1. **사용자가 URL을 입력한다.**
    - 정의의 “웹 리소스에 접속한다”는 부분을 시작하는 단계이다.
    - 역할은 서버에 특정 리소스를 요청하는 것.
    - UI와 네트워크 모듈이 동작하여 주소창에 입력된 URL을 인식하고 요청 준비를 시작한다.

2. **네트워크 모듈이 서버에 요청을 보낸다.**
    - 브라우저는 DNS 조회를 통해 도메인 이름을 IP로 변환하고, 해당 서버에 HTTP/HTTPS 요청을 전송한다.
    - 이는 “리소스를 요청한다”는 역할을 수행하는 단계이며, 네트워크 모듈이 핵심적으로 관여한다.

---

#### ② 리소스 수신 (Response)

3. **서버로부터 응답을 받는다.**
    - 서버는 HTML 문서뿐 아니라 CSS, JavaScript, 이미지, 폰트 같은 추가 리소스를 함께 전달한다.
    - 이는 “리소스를 받아온다”는 정의와 역할을 충족하며, 여전히 네트워크 모듈이 동작한다.

---

#### ③ 리소스 해석 및 표현 (Rendering)

4. **렌더링 엔진이 HTML을 파싱하여 DOM을 생성한다.**
    - “리소스를 해석한다”는 역할에 해당한다.
    - HTML 파서를 통해 문서가 토큰화되고 트리 구조로 바뀌어 DOM(Document Object Model)이 만들어진다.
    - 구성 요소는 렌더링 엔진이다.

5. **CSS를 파싱하여 CSSOM을 생성한다.**
    - 스타일 정보를 해석하는 과정으로, DOM과 결합될 준비를 한다.
    - “표현을 위한 해석”이라는 역할을 수행하며, 이 역시 렌더링 엔진이 담당한다.

6. **DOM과 CSSOM을 합쳐 Render Tree를 만든다.**
    - DOM이 문서의 구조라면, Render Tree는 “무엇을 어떻게 그릴지”를 결정한 구조이다.
    - 이는 “리소스를 화면에 표현한다”는 정의로 이어지는 중요한 중간 단계이다.

7. **Layout 과정을 거쳐 각 요소의 위치와 크기를 계산한다.**
    - 브라우저는 뷰포트 크기, CSS 속성 등을 고려해 요소들의 실제 위치를 정한다.
    - 이는 Render Tree를 구체적으로 배치하는 단계이며, 렌더링 엔진이 동작한다.

8. **Paint 과정을 거쳐 픽셀 단위로 색상, 폰트, 이미지 등을 채운다.**
    - “사용자가 열람할 수 있도록 표현한다”는 정의와 직접 연결된다.
    - 렌더링 엔진이 Render Tree의 스타일 정보를 실제 시각적 결과물로 변환한다.

9. **Compositing을 통해 최종 화면을 그린다.**
    - 여러 레이어로 나뉜 요소들을 GPU로 합성하여 화면에 출력한다.
    - 이렇게 해서 사용자는 웹 페이지를 시각적으로 볼 수 있게 된다.

---

#### ④ 상호작용 (Interaction)

10. **자바스크립트 엔진이 실행된다.**
    - DOM과 CSSOM을 조작하거나 서버와 비동기 통신을 수행해 페이지를 동적으로 변화시킨다.
    - 이는 정의의 “사용자와 상호작용한다”는 부분을 실현하는 과정이며, JavaScript 엔진이 관여한다.

11. **데이터 저장소와 보안 모듈이 작동한다.**
    - 쿠키, LocalStorage, IndexedDB 등을 통해 사용자의 상태(예: 로그인)를 유지하고, HTTPS나 SOP 같은 정책으로 안전하게 실행되도록 보장한다.
    - 이는 단순한 표현을 넘어 지속적이고 안전한 상호작용을 가능하게 한다.  

---

## 2. DOM과 Virtual DOM이란?

### 2-1. DOM은 브라우저 동작에서 어떤 역할을 맡는가?
- 브라우저 동작 과정 중 **"리소스 해석 및 표현(Rendering)"**과 **"상호작용(Interaction)"** 두 부분 모두에서 핵심 역할을 담당한다.
- **화면 표현(Rendering)**: DOM 트리는 CSSOM과 결합되어 Render Tree를 만들고, 이를 바탕으로 Layout → Paint → Compositing 단계를 거쳐 최종 화면이 표현된다.
- **상호작용(Interaction)**: DOM 트리는 자바스크립트 엔진과 연결된 API를 통해 조작 가능하다. JS 코드가 DOM을 수정하면 브라우저는 다시 Render Tree를 갱신해 화면을 업데이트한다.

즉, DOM은 **표현과 상호작용을 모두 가능하게 하는 공통 기반**이다.

---

### 2-2. DOM이란 무엇인가, 왜 만들어졌는가?
- DOM은 HTML, XML 같은 문서를 **객체(Object)로 표현하고 조작하기 위한 표준화된 인터페이스**다.
- 초창기에는 브라우저마다 HTML 문서를 해석하고 제어하는 방식이 달라, 동일한 코드가 브라우저마다 다르게 동작하는 문제가 있었다.
- 이를 해결하기 위해 W3C가 DOM을 정의했다.
   - **문서를 구성하는 요소(Element), 속성(Attribute), 텍스트(Text)를 객체(Node)로 표현**한다.
   - 이 객체들은 **트리(Tree) 구조**로 연결된다.
   - 프로그래밍 언어(주로 자바스크립트)는 DOM API를 통해 문서의 구조나 내용을 탐색하고 수정할 수 있다.
- DOM 트리란 "W3C가 정의한 DOM 인터페이스 규격"에 따라 문서를 객체화한 결과물이다.

---

### 2-3. DOM 트리는 언제, 어떻게 만들어지는가?
- 브라우저가 HTML 문서를 네트워크로 받아오면, **렌더링 엔진(Rendering Engine)**이 이를 해석하여 DOM 트리를 생성한다.

#### 생성 과정
1. **토큰화(Tokenization)**
   - HTML 파서(HTML Parser)가 HTML 텍스트를 **토큰**(예: `<div>`, `</div>`, `<p>`) 단위로 쪼갠다.
2. **노드 객체 변환(Node Creation)**
   - 각 토큰은 **노드 객체(Node)**로 변환된다. (Element Node, Text Node, Attribute Node 등)
   - 이 과정은 렌더링 엔진 내부의 **DOM 생성 로직**에서 처리한다.
3. **트리 구조 형성(Tree Construction)**
   - 변환된 노드들이 부모-자식 관계를 맺어 계층적 구조를 형성한다.
   - 이 단계 역시 렌더링 엔진이 담당한다.
4. 최종적으로 **DOM 트리(DOM Tree)**가 완성된다.

#### 예시
```html
<div>
  <p>Hello</p>
</div>
```

---

### 2-4. Virtual DOM이란 무엇인가?
- Virtual DOM은 **실제 DOM을 추상화한 가벼운 자바스크립트 객체 트리**이다.  
- 브라우저가 제공하는 무거운 DOM 대신, **메모리 상의 단순화된 트리 구조**로 UI 상태를 표현한다.  
- 이 구조는 실제 DOM과 1:1로 매칭되지만, 훨씬 단순하고 빠르게 생성·비교할 수 있다.  

---

### 2-5. Virtual DOM은 왜 만들어졌는가?
- **DOM 조작은 비용이 크다.**  
  - DOM을 직접 변경할 때마다 렌더링 파이프라인(Layout → Paint → Compositing)이 실행될 수 있다.  
  - 변화가 잦은 현대 웹 애플리케이션에서는 성능 저하의 원인이 된다.  
- **UI 변화가 빈번해졌다.**  
  - SPA(Single Page Application)와 같은 환경에서는 상태 변화가 많고 DOM 업데이트도 자주 일어난다.  
- 따라서 Virtual DOM은 **불필요한 DOM 업데이트를 줄이고, 변경된 부분만 효율적으로 반영하기 위해** 도입되었다.  

---

### 2-6. Virtual DOM의 동작 과정
1. **상태(State) 변경**  
   - 애플리케이션의 상태가 바뀌면, 새로운 Virtual DOM 트리를 생성한다.  

2. **Diffing (비교)**  
   - 이전 Virtual DOM과 새 Virtual DOM을 비교하여 **어떤 부분이 달라졌는지 탐지**한다.  

3. **Reconciliation (조정)**  
   - Diff 결과를 바탕으로 **실제 DOM에서 변경된 부분만 업데이트**한다.  
   - 그 결과, 최소한의 Layout/Paint/Compositing만 발생한다.  

---


## 3. CSR / SSR (+ SPA / MPA)

### 3-1. CSR (Client Side Rendering)
- 클라이언트(브라우저)에서 렌더링하는 방식.
- 서버는 **뼈대 HTML + JS 번들**만 내려주고, 브라우저가 JS를 실행하여 **DOM 트리를 만들고 화면을 그림**.

**특징**
- 최초 로딩은 느림 → JS 다운로드 + 실행 + 렌더링 과정 필요.
- 이후 페이지 전환은 빠름 → 새 HTML 요청 대신, JS가 DOM을 수정하여 화면 변경.
- SPA(Single Page Application)와 밀접하게 연결됨.

---

### 3-2. SSR (Server Side Rendering)
- 서버에서 HTML을 완성해서 내려주는 방식.
- 브라우저는 받은 HTML을 그대로 렌더링만 하면 됨.

**특징**
- 최초 로딩은 빠름 → 완성된 HTML을 바로 보여줄 수 있음.
- 하지만 페이지 전환 시마다 서버에서 HTML 전체를 다시 받아야 하므로 느릴 수 있음.
- 전통적인 MPA(Multi Page Application)와 연결됨.
- 최근에는 Next.js 같은 프레임워크에서 **SSR + CSR 하이브리드** 가능.

---

### 3-3. SPA (Single Page Application)
- 페이지가 **1개 HTML 뼈대**로만 구성된 애플리케이션.
- 최초 로드 시 모든 리소스를 받고, 이후에는 페이지 이동 없이 **JS로 필요한 부분만 갱신**.

**특징**
- CSR과 궁합이 좋음.
- 빠른 사용자 경험 제공.
- 하지만 SEO(Search Engine Optimization)에 불리할 수 있음 (JS 실행 전에는 콘텐츠가 없음).
- 이를 보완하기 위해 SSR이나 SSG(Static Site Generation)과 함께 사용되기도 함.

---

### 3-4. MPA (Multi Page Application)
- 여러 개의 HTML 페이지로 이루어진 애플리케이션.
- 사용자가 링크를 클릭하면 새로운 HTML 문서를 서버에서 받아와 전체 페이지를 다시 렌더링.

**특징**
- SSR과 궁합이 좋음.
- SEO 친화적임.
- 하지만 페이지 이동마다 전체 리소스를 다시 로드해야 하므로 UX가 느려질 수 있음.

---

### 📌 SPA / MPA와 CSR / SSR의 조합

1. **SPA + CSR**
   - 한 개의 뼈대 HTML만 내려옴 → JS가 모든 정보를 채움.
   - 대표적인 React, Vue 앱.

2. **SPA + SSR**
   - 한 개의 HTML이지만, 서버가 데이터까지 채워서 내려줌.
   - 초기 화면은 SSR로 빠르게 보여주고, 이후에는 CSR로 동작.
   - 대표적인 예: Next.js

3. **MPA + CSR**
   - 여러 개의 페이지가 있지만, 각각은 뼈대 HTML + 같은 JS 번들을 내려줌.
   - 실제 화면은 JS가 렌더링을 담당 → 사실상 CSR 방식.

4. **MPA + SSR**
   - 여러 개의 페이지가 있고, 각각 완성된 HTML을 서버에서 내려줌.
   - 전통적인 웹사이트 방식 (JSP, PHP, Rails 등).

---

### 📌 핵심 정리
- **CSR ↔ SSR**: 렌더링을 **어디서** 하느냐의 차이 (클라이언트 vs 서버).
- **SPA ↔ MPA**: 애플리케이션이 **페이지를 몇 개** 사용하느냐의 차이 (하나 vs 여러 개).
- 조합을 통해 다양한 아키텍처 가능.
- 👉 **정보를 넣을지 말지는 CSR/SSR 차이**
- 👉 **문서를 더 받을지 말지는 SPA/MPA 차이**

---

## 4. React를 할 때 알아야 하는 JS

### 4-1. JavaScript(JS)란?
- 웹 브라우저에서 실행되는 스크립트 언어.
- 원래는 웹 페이지에 **동적인 기능(상호작용)**을 추가하려고 만들어짐.  
  → 버튼 클릭 시 팝업, 입력값 검증, 애니메이션 등.
- 지금은 서버(Node.js), 앱(React Native), 데스크톱 앱(Electron)까지 확장된 범용 언어.

---

### 4-2. 브라우저 동작에서 JS의 역할
브라우저는 크게 보면 **화면 표시(Rendering)**와 **상호작용(Interaction)** 두 가지를 맡는다.  
이 중에서 JavaScript는 주로 **상호작용**을 담당하는 핵심 도구다.

- **DOM 조작**
   - HTML 파싱 결과 만들어진 DOM 트리를 읽고 수정 가능.
   - 예: `document.querySelector("p").textContent = "변경됨!"`

- **CSSOM 조작**
   - 스타일을 직접 변경할 수도 있음.
   - 예: `element.style.color = "red"`

- **이벤트 처리**
   - 클릭, 키보드 입력, 스크롤 같은 사용자 행동에 반응.
   - 예:
     ```javascript
     button.addEventListener("click", () => alert("눌렀다!"));
     ```  

- **비동기 통신 (AJAX, Fetch API)**
   - 페이지 전체를 다시 로드하지 않고도 서버와 데이터 송수신 가능.
   - 예: 로그인 요청, 댓글 불러오기 등 → CSR과 SPA 구현의 기반.

- **브라우저 API 활용**
   - 쿠키, 로컬스토리지, 세션스토리지, 위치 정보, 미디어 장치 등 브라우저 기능 제어 가능.

---

### 4-3. React란?
- JavaScript **UI 라이브러리** (프레임워크 아님).
- **목적**: 사용자 인터페이스를 효율적이고 선언적으로 만들기.
- Facebook(현 Meta)에서 개발, 현재 가장 널리 쓰이는 프론트엔드 기술 중 하나.

---

### 4-4. React가 필요한 이유
1. **DOM 조작의 복잡성**
   - 버튼 하나 바꾸는 건 간단하지만, 상태(state)가 많은 앱에서는  
     "어떤 DOM을 언제 수정해야 하나?"가 매우 복잡해짐.
2. **DOM 업데이트 비용**
   - DOM은 무거워서 직접 여러 번 건드리면 성능 저하.
   - → Virtual DOM이 등장해 메모리 상에서 계산 후, 필요한 최소 변경만 DOM에 반영.
3. **상태 관리 어려움**
   - 로그인 여부, 장바구니 개수, 필터 값 등 **상태**를 화면 전체에서 공유하려면  
     직접 DOM 조작으로는 일관성 유지가 힘듦.

---

### 4-5. React의 특징
- **선언적 UI**
   - "최종 모습"만 선언하면 React가 알아서 DOM을 맞춰줌.
  ```jsx
  function App() {
    const [count, setCount] = React.useState(0);
    return (
      <div>
        <p>{count}</p>
        <button onClick={() => setCount(count + 1)}>+1</button>
      </div>
    );
  }```
- **Virtual DOM**
  - 변경 사항을 메모리 상의 **가상 트리**에서 먼저 계산
  - 실제 DOM에는 **필요한 최소 변경만 반영**
  - 불필요한 DOM 조작을 줄여 **성능 향상**

- **컴포넌트(Component) 기반**
  - UI를 **작은 단위**로 나눠서 재사용 가능
  - 예: 버튼, 카드, 네비게이션 바 등
  - **유지보수와 재사용성**이 높아짐

- **단방향 데이터 흐름**
  - 데이터는 **부모 → 자식**으로 흐른다
  - 복잡한 상태 관리 문제를 단순화
  - 필요시 **Redux, Recoil** 같은 상태 관리 도구 활용

---

### 4-6. ⚡ React의 핵심 역할
- **UI를 쉽게 만들게 해줌**
   - DOM을 직접 다루지 않고 → "최종 화면은 이렇게 보여야 한다"만 선언.
   - 복잡한 DOM 조작을 대신 처리해 개발자가 덜 고생.

- **Virtual DOM으로 성능 최적화**
   - 변경 사항을 메모리상의 가상 트리에서 먼저 계산.
   - 실제 DOM에는 꼭 필요한 최소 변경만 반영.
   - 불필요한 렌더링을 줄여 빠른 사용자 경험 제공.

- **컴포넌트 단위 개발**
   - 버튼, 카드, 메뉴 같은 UI를 작은 단위로 쪼개어 조립.
   - 재사용성 ↑ 유지보수성 ↑

---

### 4-7. React를 하기 전에 꼭 알아야 할 JavaScript 개념들
1. **기초 문법**
   - var / let / const 차이
   - 데이터 타입 (원시 타입 vs 객체 타입)
   - 함수 선언식 / 표현식 / 화살표 함수
   - 스코프와 호이스팅

2. **비동기 처리**
   - 콜백(callback)
   - Promise (`.then()`, `.catch()`)
   - async/await
   - 이벤트 루프 (콜스택 / 태스크 큐)

3. **함수와 클로저**
   - 함수는 1급 객체
   - 클로저(closure) → 상태를 기억하는 함수
   - 고차 함수, 콜백 함수

4. **객체와 this**
   - 객체 생성 (리터럴, 생성자, 클래스)
   - this 동작 원리 (일반 함수 vs 화살표 함수)
   - bind, call, apply

5. **ES6+ 문법**
   - 구조 분해 할당, 전개 연산자
   - 템플릿 리터럴
   - 모듈 시스템 (import/export)

6. **DOM 조작 & 이벤트**
   - querySelector, appendChild 등
   - addEventListener
   - 이벤트 버블링/캡처링, 이벤트 위임

7. **JS의 데이터 관리 방식**
   - 얕은 복사 vs 깊은 복사
   - 불변성(immutability) → React 상태 관리 핵심
   - 배열/객체 메서드 (map, filter, reduce 등)

8. **브라우저 환경**
   - setTimeout, setInterval
   - fetch API
   - 로컬스토리지, 세션스토리지
   - JSON.parse / JSON.stringify

---

📌 **정리**  
React는 "상태(state)를 관리하고, UI를 다시 그려주는 라이브러리".  
따라서 아래 네 가지 축이 특히 중요하다:
- **상태 관리 (불변성)**
- **비동기 처리 (Promise, async/await)**
- **ES6+ 문법**
- **DOM & 이벤트 동작 원리**  
