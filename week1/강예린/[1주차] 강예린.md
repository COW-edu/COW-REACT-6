#  

## DOM과 Virtual DOM

![image.png](https://www.notion.so/image/attachment%3Ad98278bb-8897-4702-82b2-ca70556b16c2%3Aimage.png?table=block&id=276726d2-d8a8-80b4-b99d-f3a85ef368d6&spaceId=ca504aec-1aa6-4196-a4aa-edde9e2fa42f&width=2000&userId=585b7d40-67ee-472b-b981-846d961dc0d4&cache=v2)

### DOM

Document Object Model로 HTML이란 코드로 설계된 웹페이지가 브라우저 안에서 화면에 나타나고, 이벤트에 반응하며 값을 입력받는 등 기능들을 수행할 객체들로 실체화된 형태를 의미한다.

> DOM은 HTML, XML document와 상호작용하고 표현하는 API이다. 
DOM은 browser에서 로드되고 Node 트리(각 노드는 document의 부분)로 표현하는 document 모델
> 

> DOM은 HTML과 자바스크립트를 이어주는 공간으로 내가 작성한 HTML을 자바스크립트가 이해할 수 있도록 객체로 변환하는 것
> 

Document는 HTML, XML을, Object는 노드 트리

즉 노드는 HTML 태그

**가장 일반적인 노드 유형**

- DOCUMENT_NODE (ex. `window.document`)
- ELEMENT_NODE (ex. `<html>, <body>, <a>, <p>, <script>, <style>, <h1>`)
- ATTRIBUTE_NODE (ex. `class="hi"`)
- TEXT_NODE (ex. 줄바꿈과 공백을 포함한 HTML 문서 내의 텍스트)
- DOCUMENT_FRAGMENT_NODE (ex. `document.createDocumentFragment()`)
- DOCUMENT_TYPE_NODE (ex. `<!DOCTYPE html>`)

![dom](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/DOM-model.svg/1280px-DOM-model.svg.png)

DOM은 브라우저에서 로드된다. 각자의 IDE에서 작성한 HTML은 DOM이 아니고 작성 된 **HTML 문서가 브라우저에 의해 해석되어** 실제 문서를 나타내는 노드 트리가 DOM

즉 IDE에 HTML을 작성하더라도 최종적으로 이 결과물을 보기 위해 브라우저가 필요

→ 브라우저가 이해하기 위해서는 노드(객체)로 변환해야 함

DOM은 자바스크립트로 해당 문서에 노드 추가, 삭제, 변경, 이벤트 처리, 수정 등을 가능케 하는 API를 제공

### DOM API

자바스크립트를 DOM API라고 하기도함 

자바스크립트로 새로운 노드를 추가할 수도 있음

ex)

`const newTextDiv = document.createElement('div')
const helloWorld = document.createTextNode('Hello world!')
newTextDiv.appendChild(helloWorld)
document.body.appendChild(newTextDiv)`

## 브라우저 동작 원리

1. 브라우저가 HTML을 전달 받고 
2. 파싱하고
3. 노드들로 이루어진 DOM 트리를 만듦
4. 외부의 CSS 파일과 각 노드들의 inline 스타일을 파싱하여 스타일을 입힌 **Render 트리를 만듦**
5. 각 노드들이 화면에서 정확히 어디에 나타나야 하는지에 대한 위치가 주어짐
6. paint() 메서드를 호출하면 내가 구현하고 싶었던 화면이 출력됨

이 과정을 DOM이 계속 반복 

→ **BUT** 오타 수정같은 사소한 일을 하더라도 처음부터 다시 이 과정을 수행

### DOM의 문제점

어떠한 이벤트가 발생하면 전체 노드들이 처음부터 다시 그려지게 됨

현재 대부분의 웹 사이트는 수 십개 심지어 수 백, 수 천개의 페이지로 이루어져있어 작은 변경에 불필요한 반복이 반복되어 DOM을 조작하는 소모적인 비용이 증가하게 된다.

그래서 Virtual Dom이 나옴

## Virtual Dom

Virtual DOM은 실제 DOM을 모방하는 형태로 **메모리 상에서만 존재하는 가상의 DOM**을 의미한다.

Virtual Dom은 수정사항이 여러 가지 있더라도, 가상 DOM은 한 번만 렌더링을 일으킨다.

![dom](https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/elm-runtime-virtual-dom.svg)

가상 DOM은 DOM이 생성되기 전 이전 상태 값과 수정사항을 비교하여 달라진 부분만 DOM에게 한 번에 전달하여 **딱 한 번만 렌더링**을 진행한다.

![dom](https://codingmedic.files.wordpress.com/2020/11/virtualdom.png?w=1024)

빨간 부분에 수정사항이 생겼다면 가상 DOM이 알아서 달라진 값을 탐지하여 변경하고 최종적인 결과물을 실제 DOM에 전달한다. 

만약 가상 DOM이 없었다면 DOM은 렌더링을 처음부터 해야했기 때문에 모든 동그라미가 다 빨간색으로 바뀌었을 것이다.

즉 만약 요소가 30개가 바뀌었다고 레이아웃을 30개씩 새로 하는 것이 아니라 모든 변화를 하나로 묶어서 딱 한번만 실행시킨다. 이렇게 연산 횟수를 줄일 수 있기 때문에 실제 DOM 리렌더링에 비해서 효율적

> **사실 virtual DOM이 하는 것은 DOM Fragment에 변화를 묶어서 적용시킨 다음에 기존 DOM에 던져주는 과정** virtual DOM은 이 과정을 자동화, 추상화해놓은 것에 불과
> 

큰 특징 다시 정리

- JavaScript 객체를 활용
- 메모리 상에서 동작하기에 훨씬 더 빠르게 동작
- 실제 렌더링이 되지 않기 때문에 연산 비용이 적음

## MPA와 SPA

![image.png](https://www.notion.so/image/attachment%3Aef2ab844-84a0-47bb-8156-d6b00c1d828c%3Aimage.png?table=block&id=276726d2-d8a8-80a1-95da-ebcdc4083c42&spaceId=ca504aec-1aa6-4196-a4aa-edde9e2fa42f&width=2000&userId=585b7d40-67ee-472b-b981-846d961dc0d4&cache=v2)

### SPA (Single Page Application)

**개념**

Single Page Application의 줄임말로 **하나의 페이지로 구성이 되어있는 어플리케이션**

모바일 퍼스트(Mobile First) 전략에 부합

(웹사이트나 서비스를 설계할 때 모바일 환경을 가장 우선적으로 고려하는 개발 방식)

필요한 데이터만 비동기적으로 가져와 화면의 일부만 빠르게 갱신 : **UX 향상**

초기에 모든 리소스를 한꺼번에 불러온 후 페이지 이동에서는 데이터만 주고받음 : **속도 향상**

**작동방식**

웹 에플리케이션에 필요한 모든 정적 리소스를 최초 접근 시 **한번만 다운로드**하고

이후 새로운 페이지 요청 시 **페이지 갱신에 필요한 데이터만 따로 전달받아 페이지를 갱신**

기존 페이지의 내부를 수정해서 보여주는 방식

기본적으로 SPA는 CSR 방식의 렌더링임

**장점**

1. 사용자 경험 향상! 정적 리소스를 모두 다운받기 때문에 페이지 갱신시 화면 깜빡임 X
2. 갱신에 필요한 데이터만 받기 때문에 **속도와 응답시간이 빠름**
3. 컴포넌트 기반의 코드를 작성하기 때문에 재사용성이 높음
4. 모바일 앱도 SPA와 동일한 아키텍처에서 개발되기 때문에 모바일을 염두해두면 동일한 백엔드 코드를 재사용하도록 할 수 있음

**단점**

1. 모든 리소스를 최초 접근시에 다 다운하기 때문에 **초기 구현 속도가 느림**
2. JavaScript로 구축되기 때문에 검색엔진최적화(SEO)가 어려움
3. 보안이 약하다. JavaScript는 코드 컴파일을 수행하지 않으므로 악의적인 사용자가 액세스할 수 있기 때문

→ 이 말은 java 나 c 생각하면 .java, .cpp 이런 소스코드 자체를 실행시키지않고 컴파일 후 .exe, .class 파일을 받아서 실행함

→ 그러나 js는 소스코드가 그대로 전달되고 클라이언트에서 실행되기 때문에 악의적인 액세스 있을 수 있음

### MPA (Multi Page Application)

**개념**

Multi Page Application의 줄임말로 SPA의 반대되는 개념

= **다중 페이지 어플리케이션** 

작동방식

각 페이지별로 HTML문서가 따로 존재하여 페이지를 이동할 때마다 새로운 html 페이지를 받아와서

새로 렌더링하는 전통적인 웹페이지 구성 방식

**장점**

1. SEO(검색 엔진 최적화): 여러 페이지를 생성할 수 있기 때문에 훨씬 더 많은 수의 키워드를 타겟팅할 수 있고
    
    따라서 Google에서 얻을 수 있는 유기적 트래픽의 양이 자동으로 향상됨
    
    → 각 페이지가 독립적인 URL과 완성된 콘텐츠를 가지고 있기 때문에 SEO에 더 유리
    

**단점**

1. 페이지 이동시 새로운 파일을 받아야하기 때문에 **로딩 시간 증가**
2. 여러 페이지의 규모가 너무 커지면 유지 관리 및 업데이트가 어려울 수 있음

 

## CSR과 SSR

![image.png](https://www.notion.so/image/attachment%3A3b90d98f-7640-4139-a3c8-54f2947ca08f%3Aimage.png?table=block&id=278726d2-d8a8-8060-af95-d05bb5d44b24&spaceId=ca504aec-1aa6-4196-a4aa-edde9e2fa42f&width=2000&userId=585b7d40-67ee-472b-b981-846d961dc0d4&cache=v2)

서버사이드렌더링의 약자이다. 말 그대로 서버쪽에서 렌더링을 하여 화면을 보여주는 방식을 말한다. 

서버로부터 완전하게 만들어진 HTML 파일을 받아와 화면을 그리기 때문에 **첫 화면 로딩 속도가 빠르다.**

SSR(Server-Side Rendering)은 말 그대로 **브라우저(클라이언트)가 아닌 서버에서 미리 HTML을 만들어서 브라우저로 보내주는 방식**

→ 사용자는 요청과 동시에 **완성된 HTML 문서**를 받기 때문에 첫 화면 로딩 속도가 빠름

**동작과정**

1. **사용자가 웹사이트에 접속 요청**
2. **서버에서 HTML 생성**
    
    서버는 React, Vue 같은 프레임워크 또는 템플릿 엔진을 활용해 렌더링이 완료된 HTML을 만듦.
    
3. **브라우저에 HTML 전달 → 빠른 화면 표시**
    
    이때는 HTML만 있기 때문에 텍스트와 레이아웃은 보이지만 버튼 클릭 같은 동적인 조작은 불가능
    
4. **브라우저가 JS 파일 다운로드 및 실행**
    
    `<script>` 태그에 연결된 JavaScript를 가져오고 실행
    
    이를 하이드레이션(hydration) 과정이라고 부르기도 함
    
5. **UI 상호작용 활성화**
    
    브라우저가 JS 프레임워크를 실행하면서 기존에 HTML로 그려진 화면에 이벤트 리스너가 붙음
    
    이제 클릭, 입력, 네비게이션 같은 동작이 가능해짐
    
6. **사용자 경험(UX) 완성**
    
    초기엔 빠르게 화면을 보여주고 이후 JS가 실행되면서 완전한 인터랙티브 웹앱이 됨
    

장점

> 첫페이지 로딩속도가 빠르다.
검색엔진 최적화가 가능하다.
> 

단점

> 초기 로딩 이후 페이지 이동 시 속도가 CSR에 비해 느리다 (깜빡임 이슈- 매번 새로고침 해야하기 때문에)
서버 과부하TTV(Time To View) 와 TTI(Time To Interact) 의 공백시간
> 

![image.png](https://www.notion.so/image/attachment%3A6b754451-9a75-4dd3-856d-7226e7221801%3Aimage.png?table=block&id=278726d2-d8a8-8008-9053-cfb2299216ab&spaceId=ca504aec-1aa6-4196-a4aa-edde9e2fa42f&width=2000&userId=585b7d40-67ee-472b-b981-846d961dc0d4&cache=v2)

CSR(Client-Side Rendering)은 브라우저(클라이언트)가 직접 렌더링을 담당하는 방식

서버에서는 비어 있는 HTML 골격 + JS 파일 링크만 내려주고, 브라우저가 JS를 실행해 화면을 완성

화면 그리기의 주체가 서버(SSR) → 클라이언트(CSR)

HTML 파싱부터 JS 읽기까지 브라우저에서 하기때문에 처음에 화면을 띄우는 데 시간이 좀 걸림

**동작과정**

1. **사용자 요청**
    
    사용자가 웹사이트에 접속.
    
2. **서버 응답 (CDN 활용)**
    
    서버는 HTML과 JS 파일을 반환
    
    보통 CDN(Content Delivery Network)을 통해 가까운 서버에서 빠르게 파일을 전송받음
    
    이때 내려오는 HTML은 거의 빈 껍데기 상태 !!
    
3. **브라우저 HTML/JS 다운로드**
    
    HTML과 JS를 다운받는 동안 사용자는 빈 화면을 보게 됨
    
4. **브라우저 JS 실행**
    
    JS 파일이 실행되며 API 호출을 통해 필요한 데이터를 요청
    
    화면에는 로딩 중임을 표시하는 placeholder(스피너, skeleton UI)가 보임
    
5. **서버 API 응답 → 데이터 바인딩**
    
    API에서 데이터를 받아오면 placeholder 자리에 실제 콘텐츠를 채워 넣음
    
6. **상호작용 가능**
    
    이제 페이지가 완전히 그려지고, 사용자는 클릭·입력 등 즉시 인터랙션이 가능
    

단점

**장점**

- 페이지 전환 시 새로고침 없이 부드럽게 동작 → 사용자 경험(UX) 향상
- 한 번 초기 로딩 후에는 빠른 화면 렌더링 가능
- 필요한 데이터만 가져오기 때문에 네트워크 트래픽 절감

**단점**

- 초기 로딩 느림 (HTML → JS → API 호출까지 해야 화면이 보임)
- SEO 취약 (검색 엔진 크롤러는 JS 실행 전의 빈 HTML만 읽음ㄴ)