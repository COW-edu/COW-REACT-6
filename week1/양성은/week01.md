브라우저는 어떻게 동작하는가?
1. 브라우저의 주요 역할과 구조
브라우저의 가장 기본적인 기능은 사용자가 요청한 웹 자원(HTML 문서, 이미지 등)을 서버에서 가져와 화면에 보여주는 것이다.
<구조>
사용자 인터페이스 (UI): 주소 표시줄, 이전/다음 버튼, 북마크 등 우리가 직접 보고 사용하는 부분
브라우저 엔진: 사용자 인터페이스와 아래 설명할 렌더링 엔진을 연결하고 제어하는 중간 관리자 역할
렌더링 엔진: 웹 페이지를 실제로 화면에 그리는 가장 핵심적인 부분입니다. HTML, CSS 코드를 해석해 우리가 보는 시각적인 결과물로 만듦
통신: HTTP 요청과 같은 인터넷 통신을 담당하여 서버로부터 파일을 가져옴.
자바스크립트 해석기: 웹 페이지의 동적인 기능을 담당하는 자바스크립트 코드를 읽고 실행
UI 백엔드: 기본적인 창이나 버튼 같은 위젯을 그림.
자료 저장소: 쿠키나 캐시 같은 데이터를 컴퓨터에 저장하는 역할
2. 렌더링 엔진의 동작
렌더링 엔진의 역할은 요청 받은 내용을 브라우저 화면에 표시하는 일을 함.
1) HTML 파싱(Parsing) → DOM 트리 생성
렌더링 엔진은 HTML 문서를 파싱하고 "콘텐츠 트리" 내부에서 태그를 DOM 노드로 변환
2) 스타일 정보와 HTML 표시 규칙은 "렌더 트리"라고 부르는 또 다른 트리를 생성
3)배치
각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다.
4)그리기
UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어 내는 그리기 과정이다.

->점진적으로 진행!

파싱
컴퓨터가 코드(HTML, CSS 등)를 읽고 자신이 이해하고 사용할 수 있는 논리적인 구조로 변환하는 과정-> 파스트리 또는 문법 트리라고 함
1. 어휘 분석 - 단어로 나누기 
어휘 분석은 자료를 토큰으로 분해하는 과정
예를 들어, 2+3-1이라는 코드는 2, +, 3, -, 1이라는 5개의 토큰으로 분해된다.
이 역할을 하는 것을 어휘 분석기라고 함.
2. 구문 분석 - 문장으로 조립
어휘 분석기가 전달한 토큰들을 해당 언어의 문법규칙에 따라 분석하여, 이들이 어떻게 연결되는지 구조적인 관계를 파악 -> 파스 트리가 생성 -> 이 역할을 하는 것이 파서





HTML 파싱의 특징: 너그러움
 문법이 조금 틀려도 알아서 수정이 됨
CSS 파싱의 특징: 엄격함
반면, CSS는 매우 명확하고 엄격한 문법 규칙을 가지고 있음. 만약 문법에 맞지 않는 코드가 있다면, 브라우저는 그 부분을 그냥 무시하고 다음 규칙으로 넘어감

DOM 트리
HTML 파서가 모든 과정을 마치고 나면, 최종적으로 DOM트리가 만들어짐.
DOM은 문서 객체 모델(Document Object Model)의 준말이다
자바스크립트는 텍스트 파일인 HTML 문서를 직접 읽고 수정할 수 없기 때문에 필요함

HTML 파싱 알고리즘의 두 단계
1. 토큰화
- HTML 문서를 작은 단위로 나눔
2. 트리 구축
- 토큰을 받아서 DOM 트리를 만듦
- 이 트리는 브라우저가 화면에 보여줄 구조

토큰화 알고리즘 : 상태 기계
즉, 현재 상태에 따라 다음 입력을 어떻게 처리할지 결정해요.
처리 흐름:
- 초기 상태: "자료 상태"
- < 문자를 만나면 -> "태그 열림 상태"로 전환
- a부터 z까지 문자를 만나면 -> "태그 이름 상태"
- > 문자를 만나면 -> 태그가 닫혔다는 뜻 -> html 토큰 생성
이런 식으로 문자를 하나씩 읽으면서 상태를 바꾸고, 토큰을 만들어 DOM 트리에 추가

트리 구축 알고리즘
HTML 문서를 브라우저가 읽을 때, 단순히 글자만 읽는게 아니라 구조화된 트리로 바꿈

과정
- 파서 생성 -> 문서 객체가 만들어짐
- 토큰화 단계 -> HTML을 태그 단위로 나눔
- 트리 생성자가 각 토큰을 DOM 요소로 바꿔서 트리에 추가함
- 열린 태그는 스택에 저장 -> 닫히지 않은 태그나 잘못된 중첩을 자동으로 교정함
- 상태 기계처럼 작동 → 현재 상태에 따라 다음 행동이 달라짐
- 문서 파싱이 끝나면 브라우저는 스크립트 실행, 이벤트 발생 등을 시작



브라우저 오류 처리

파서는 적어도 다음과 같은 오류를 처리해야 한다.

어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다.
파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다. HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다.
인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다.
이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.

렌더 트리 구축
렌더 트리는 화면에 실제로 표시될 요소들만 포함된 시각적 구조

트리 구축 과정
DOM -> 렌더 트리로 변환
루트 렌더 객체
- 파이어폭스: ViewPortFrame
- 웹킷: RenderView

스타일 계산
렌더 트리를 구축하려면 각 렌더 객체의 시각적 속성에 대한 계산이 필요한데 이것은 각 요소의 스타일 속성을 계산함으로써 처리
CSS 스타일 속성으로 변환
스타일을 계산하는 일에는 다음과 같은 몇 가지 어려움이 따른다.

1. 스타일 데이터는 구성이 매우 광범위한데 수 많은 스타일 속성들을 수용하면서 메모리 문제를 야기할 수 있다.
2. 최적화되어 있지 않다면 각 요소에 할당된 규칙을 찾는 것은 성능 문제를 야기할 수 있다. 각 요소에 할당된 규칙 목록을 전체 규칙으로부터 찾아내는 것은 과중한 일이다. 맞는 규칙을 찾는 과정은 얼핏 보기에는 약속된 방식으로 순탄하게 시작하는 것 같지만 실상 쓸모가 없거나 다른 길을 찾아야만 하는 복잡한 구조가 될 수 있다.
예를 들어 이런 복합 선택자가 있다.





DOM과 Virtual Dom이란?
DOM이란?
DOM은 HTML, XML 문서와 상호작용하고 표현하는 API이며, 브라우저에서 로드되어 노드 트리로 표현되는 문서 모델임.
HTML 문서를 브라우저가 읽어서 객체(노드) 트리로 바꾼 것
이 트리를 통해 자바스크립트가 문서를 조작, 수정, 이벤트 처리할 수 있음
노드(Node)
가장 일반적인 노드 유형(nodeType)

DOCUMENT_NODE (ex. window.document)
ELEMENT_NODE (ex. <html>, <body>, <a>, <p>, <script>, <style>, <h1>)
ATTRIBUTE_NODE (ex. class="hi")
TEXT_NODE (ex. 줄바꿈과 공백을 포함한 HTML 문서 내의 텍스트)
DOCUMENT_FRAGMENT_NODE (ex. document.createDocumentFragment())
DOCUMENT_TYPE_NODE (ex. <!DOCTYPE html>)

->HTML이 곧 DOM이 아님 ! DOM은 HTML과 자바스크립트를 이어주는 공간으로, 내가 작성한 HTML을 자바스크립트가 이해할 수 있도록 객체(object)로 변환

Virtual Dom
Virtual Dom(이하 가상 DOM)은 수정사항이 여러 가지 있더라도, 가상 DOM은 한 번만 렌더링을 일으킨다.
가상 DOM은 DOM이 생성되기 전, 이전 상태 값과 수정사항을 비교하여 달라진 부분만 DOM에게 한 번에 전달하여 딱 한 번만 렌더링을 진행한다.(성능이 최적화됨)
Virtual DOM은 UI의 이상적인 또는 가상적인 표현을 메모리에 저장하고 React Dom과 같은 라이브러리에 의해 실제 DOM과 동기화하는 프로그래밍 개념이다.
-> 버퍼링 캐싱의 역할을 한다고 볼 수 있다.

"직접 DOM에 접근하는 것은 지양해야 한다."
DOM이 직접 변경된다면 사소한 변경사항에도 전체가 재렌더링 되기 때문에 브라우저에 과부하가 올 수 있다










1. SPA
Single Page Applicaion으로 하나의 페이지로 구성된 애플리케이션
2. MPA
Multi Page Application으로 탭을 이동할 때마다 새로운 html 페이지를 받아와서 페이지를 새로 렌더링하는 전통적인 웹페이지 구성 방식
3. CSR/SSR과 SPA/MPA와의 관계
일반적으로 SPA에서는 CSR 방식을 사용하고, MPA는 SSR 방식을 사용
4. CSR/SSR의 개념
CSR은 Client Side Rendering으로 클라이언트에서 렌더링을 하고, SSR은 Server Side Rendering으로 서버에서 렌더링을 하는 방식이다. Client와 Server 중 어느 쪽에서 렌더링을 준비하는지에서 차이가 있다.
SSR은 요청할 때 즉시 만들기 때문에 데이터가 변하는 페이지에 적합하다. 반대로 SSG는 미리 다 만들어두기 때문에 바뀔 일이 거의 없는 페이지에 적합하다. 
5. CSR의 동작 과정
- 사용자가 웹사이트에 접속
- 서버는 빈 뼈대의 HTML만 응답
- 브라우저가 JS 파일을 다운로드
- JS가 DOM을 동적으로 생성하여 화면을 구성
6. SSR의 동작 과정
- 사용자가 웹사이트에 접속
- 서버가 완성된 HTML + CSS + JS를 즉시 생성해 전달
- 브라우저는 즉시 화면을 표시
- 이후 JS 코드를 다운로드하고 로직을 연결
7. CSR에 SSR/SSG을 도입하는 방법
SSR이나 SSG를 도입하려면 프레임워크 없이 직접 서버를 구성할 수도 있고(express.js, nest.js 등), 프레임워크를 활용할 수도 있다. Next.js, Gatsby.js, Nuxt.js, Angular Universal 같은 프레임워크는 SSR/SSG를 쉽게 적용할 수 있게 도와주지만, 코드 복잡도가 높아지고 직접 제어하기 어려운 블랙박스 영역이 생길 수 있다는 단점이 있다.