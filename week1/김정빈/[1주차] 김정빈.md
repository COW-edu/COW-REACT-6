# 1주차 과제

## 브라우저의 동작 과정
1. URL 입력
    사용자가 주소창에 URL을 입력한다
    
2. DNS 조회
    브라우저는 URL의 실제 ip주로를 알아야 서버에 연결할 수 있다
    이를 위해서 DNS 서버에 요청을 보내 IP주소를 받을 수 있다

3. 서버와 연결 (TCP/HTTPS)
    브라우저는 IP 주소로 지정된 서버에 TCP 연결을 맺는다
    HTTPS라면 TLS/SSL 암호화 핸드셰이크 과정을 거쳐 보안 채널을 만든다

4. HTTP 요청
    브라우저는 서버에 HTTP 요청 메시지를 보낸다
    서버는 응답을 보낸다

5. 렌더링 과정
    - 브라우저는 받은 데이터를 사용자가 볼 수 있는 화면으로 변환한다
    - HTML 파싱 → DOM(Document Object Model) 생성
    - HTML 코드를 읽고 문서 구조 트리를 만든다
    - CSS 파싱 → CSSOM(CSS Object Model) 생성
    - 스타일시트를 해석해 각 요소의 스타일을 결정한다
    - DOM + CSSOM → 렌더 트리(Render Tree)
    - 화면에 표시할 요소와 스타일이 합쳐진 구조가 만들어진다
    - 레이아웃(Layout)
    - 각 요소의 크기와 위치를 계산한다
    - 페인팅(Painting)
    - 색상, 글꼴, 배경, 그림자 등을 실제 픽셀 단위로 그린다
    - 합성(Compositing)
    - 여러 레이어를 GPU에서 최종적으로 합성해 화면에 출력한다

6. JavaScript 실행
    브라우저 내 JavaScript 엔진이 JS 코드를 실행한다

7. 사용자 상호작용 처리
    클릭, 입력, 스크롤 같은 이벤트를 처리한다.
    필요 시 다시 렌더링 과정을 일부 수행한다(리플로우, 리페인트)

**결론**
    브라우저는 URL 해석 → 서버 요청/응답 → HTML/CSS/JS 파싱 → 렌더링 → 사용자에게 시각적으로 출력 과정을 반복하며 동작
    
## DOM

DOM은 브라우저가 HTML 문서를 메모리에 표현한 트리 구조다. 각 HTML 태그는 노드가 되고, 부모 관계로 연결된다.

- 핵심 개념
    - 트리 구조: document → html → head/body → 요소들(div, a, p …) → 텍스트 노드
    - 조작 API: JS로 요소를 찾고(querySelector), 만들고(createElement), 붙이고(append), 지우고(remove) 속성과 스타일을 바꾼다.
    - 렌더링과의 연결: DOM 변경은 레이아웃(Layout/리플로우)과 페인팅(리페인트)을 유발할 수 있다.(성능이 나쁨)

- 자주 하는 작업
    - 찾기/순회: querySelector, getElementById, parentNode/children
    - 생성/삽입/삭제: createElement, append, prepend, remove
    - 속성/스타일: setAttribute, classList.add/remove/toggle, style.xxx
    - 이벤트: addEventListener로 클릭/입력 등 상호작용 처리

- 성능 팁
    - DOM 변경은 모아서 한 번에(배치) 수행한다.
    - 여러 노드를 추가할 때 DocumentFragment를 사용한다.
    - class 변경으로 스타일을 일괄 적용하고, 빈번한 레이아웃 조회(offsetWidth 등)는 최소화한다(레이아웃 스래싱 주의).
    - 애니메이션/스크롤 관련 업데이트는 requestAnimationFrame에서 처리한다.

## Virtual DOM

Virtual DOM은 실제 DOM 앞에 놓인 가상의 트리다. 상태가 바뀌면 새 가상 트리를 만들고 이전 트리와 비교(diff)해 최소한의 변경만 실제 DOM에 반영한다(React 같은 라이브러리가 사용하는 방식).

- 동작 방식
    - 렌더 함수가 상태 → 가상 노드 트리(객체)로 변환
    - 이전 트리와 새 트리를 비교하고 변경 지점만 실제 DOM에 적용(성능이 뛰어남)
    - 리스트 렌더링 시 key로 변경 추적을 돕는다

- 장점
    - 선언적 UI: “어떻게”보다 “무엇을”에 집중
    - 불필요한 DOM 조작 감소 → 평균적인 성능 향상과 예측 가능한 업데이트
    - 플랫폼 추상화: React DOM/Native 등 다른 렌더러로 확장 가능

- 한계
    - 매우 단순한 화면에서는 오히려 오버헤드가 될 수 있다(트리 생성/비교 비용)
    - 미세한 DOM 최적화를 직접 제어하기 어렵다

- 언제 유리한가
    - 상태 변경이 잦고 UI가 중간 이상 복잡한 앱
    - 컴포넌트 기반 개발, 재사용/테스트 용이성이 중요한 경우

- 관련 기술
    - React, Preact, Vue(VDOM 기반 최적화) 등


## MPA

MPA(Multi-Page Application)는 페이지마다 별도의 HTML 문서를 요청해 전체 새로고침으로 화면을 바꾸는 전통적인 웹 구조다.
사용자가 페이지 이동을 요청할 때마다 서버가 새로운 HTML 페이지를 렌더링해서 클라이언트로 보낸다
페이지 전환 시 전체 문서가 새로고침된다

- 특징
    - 라우팅: 서버 라우팅 중심(각 URL → 새로운 문서 응답)
    - 자원 로드: 페이지 전환마다 JS/CSS/이미지 등을 새로 요청할 수 있음
    - SEO: 서버가 완성된 HTML을 반환하므로 기본적으로 유리

- 장점
    - 초기 구성 단순, 보안/접근성/SEO 친화적
    - 페이지별 캐싱 효과가 크고, 서버 템플릿과 궁합이 좋음

- 단점
    - 페이지 전환 시 전체 리로드로 체감 속도가 느릴 수 있음
    - 클라이언트 상태 공유가 어렵고, 중복 자원 로드 가능성

- 활용 예
    - 콘텐츠 위주 사이트, 블로그/뉴스/카탈로그형 서비스

## SPA

SPA(Single-Page Application)는 하나의 HTML을 처음에 로드하고, 이후에는 클라이언트 라우팅으로 화면을 바꾸며 API로 데이터만 주고받는 방식이다.
웹 애플리케이션을 하나의 HTML 페이지로 구성하는 방식이다.

- 특징
    - 라우팅: 클라이언트 라우터(history API)로 URL ↔ 화면 상태 동기화
    - 데이터: REST/GraphQL 등 API 통신으로 뷰 갱신
    - 번들: 초기 자바스크립트 번들이 큼 → 코드 스플리팅이 중요

- 장점
    - 빠른 화면 전환, 앱 같은 UX, 풍부한 상호작용
    - 클라이언트 상태관리로 복잡한 UI를 구조화하기 쉬움

- 단점
    - 초기 로드 무겁고 TTI가 늦을 수 있음
    - SEO 취약(SSR/SSG로 보완 필요)
    - 메모리 누수/라우팅 누락 등 클라이언트 복잡도 증가

- 활용 예
    - 대시보드, 관리도구, 실시간 상호작용이 많은 웹앱

- 최적화 포인트
    - 코드 스플리팅/지연 로딩, prefetch, 이미지 최적화
    - 상태 관리 전략 정립(Zustand/Redux/React Query 등 데이터/서버 상태 분리)

## CSR vs SSR

CSR(Client-Side Rendering)과 SSR(Server-Side Rendering)은 “HTML을 어디서 언제 만들 것인가”의 차이다.

- 정의
    - CSR: 서버는 주로 빈 껍데기 HTML과 JS 번들을 전달, 브라우저가 JS 실행으로 DOM을 만들고 그린다.
    - SSR: 서버에서 요청 시점에 완성된 HTML을 만들어 클라이언트에 전달한다. 이후 클라이언트가 하이드레이션으로 상호작용을 붙인다.

- 성능/UX 비교(일반적 경향)
    - 초기 표시(First Paint): SSR 유리(HTML 바로 렌더 가능)
    - 상호작용 가능 시점(TTI): SSR은 하이드레이션 비용 존재, CSR은 번들/렌더 시간이 직접 영향
    - 네트워크/캐시: SSR은 HTML 캐싱 전략을 활용 가능, CSR은 API 캐싱/오프라인 전략과 궁합

- SEO
    - SSR이 기본적으로 유리. CSR은 프리렌더링/SSG/서버 API를 통한 메타 태그 주입 등 보완 필요

- 개발 복잡도
    - CSR: 빌드와 배포 단순(정적 호스팅 가능)하나, SEO/초기 성능 튜닝 필요
    - SSR: 런타임 서버가 필요하고 라우팅/데이터 패칭/캐싱 정책 등 고려할 요소가 많음

- 하이브리드 패턴
    - SSG(Static Site Generation): 빌드 시 HTML 생성(블로그/문서 사이트에 적합)
    - ISR(Incremental Static Regeneration): 정적 페이지를 부분적으로/주기적으로 재생성
    - RSC(React Server Components): 컴포넌트 단위로 서버 렌더링/클라이언트 분리 최적화

- 선택 가이드(요약)
    - SEO 중요/초기 표시 빠르게: SSR/SSG/ISR 고려
    - 사내 도구/대시보드 중심: CSR 중심 + 필요한 페이지만 SSR
    - 글로벌 트래픽/캐싱 중요: SSR + 에지 캐시/SSG 혼합

실제로는 CSR, SSR을 혼합해서 많이 사용한다.
Next.js (React) → 기본 SSR 지원, 필요시 CSR.
Nuxt.js (Vue) → SSR, SSG 지원.
초기 페이지는 SSR로 빠르게 보여주고, 이후 라우팅은 CSR로 빠르게 전환하는 방식이 일반적이다.